# 任务配置初始化策略

## 设计变更

### 之前的行为（已废弃）

```go
// 检查是否已有任务配置
configs := s.registry.GetAllTasks()
if len(configs) > 0 {
    log.Println("Tasks already initialized from registry")
    return nil  // 跳过初始化
}
```

**问题：**
- 首次启动后，tasks.json 被创建
- 之后每次启动都跳过初始化
- 如果修改了代码中的配置（如间隔时间），不会生效
- 配置与代码不一致

### 当前的行为（推荐）

```go
// 每次启动时都根据配置重新初始化任务，确保配置与代码保持一致
log.Println("Initializing tasks from config...")

// ... 创建任务配置

if err := s.upsertTask(reminderTask); err != nil {
    return err
}
```

**优点：**
- ✅ 每次启动都重新初始化
- ✅ 配置始终与代码保持一致
- ✅ 修改代码配置后立即生效
- ✅ 简化了配置管理

## Upsert 逻辑

### 实现

```go
// upsertTask 添加或更新任务（如果已存在则更新，否则添加）
func (s *Scheduler) upsertTask(task *TaskConfig) error {
    existing := s.registry.GetTask(task.ID)
    if existing != nil {
        // 任务已存在，更新配置
        return s.registry.UpdateTask(task)
    }
    // 任务不存在，添加
    return s.registry.AddTask(task)
}
```

### 行为

| 场景 | 行为 |
|------|------|
| 首次启动 | 添加所有任务到 tasks.json |
| 后续启动 | 更新现有任务的配置 |
| 修改间隔时间 | 下次启动时自动更新 |
| 修改总结时间 | 下次启动时自动更新 |
| 添加新任务 | 自动添加到 tasks.json |

## 配置示例

### config.yaml 中的配置

```yaml
minute_interval: 45      # 工作记录提醒间隔
summary_time: "11:00"    # 每日总结时间
max_log_size_mb: 10      # 日志大小限制
```

### 启动时的初始化过程

```
2026/01/23 12:00:00 Initializing tasks from config...
2026/01/23 12:00:00 Initialized task: 工作记录提醒 (interval: 45 minutes, next run: 12:45:00)
2026/01/23 12:00:00 Initialized task: 每日总结生成 (time: 11:00, next run: 2026-01-24 11:00:00)
2026/01/23 12:00:00 Initialized task: 日志文件轮转 (interval: 3 hours, next run: 2026-01-23 15:00:00)
2026/01/23 12:00:00 Tasks initialized and saved to registry
```

### tasks.json 中的结果

```json
{
  "tasks": [
    {
      "id": "work-reminder",
      "name": "工作记录提醒",
      "type": "interval",
      "enabled": true,
      "interval_minutes": 45,
      "next_run": "2026-01-23T12:45:00+08:00",
      "last_run": "0001-01-01T00:00:00Z"
    },
    {
      "id": "daily-summary",
      "name": "每日总结生成",
      "type": "daily",
      "enabled": true,
      "time": "11:00",
      "next_run": "2026-01-24T11:00:00+08:00",
      "data": {}
    },
    {
      "id": "log-rotate",
      "name": "日志文件轮转",
      "type": "interval",
      "enabled": true,
      "interval_minutes": 180,
      "next_run": "2026-01-23T15:00:00+08:00"
    }
  ]
}
```

## 配置修改流程

### 场景 1：修改提醒间隔

**步骤：**
1. 修改 `config.yaml`：`minute_interval: 30`（从 45 改为 30）
2. 重启服务
3. 自动更新 tasks.json 中的 `interval_minutes`
4. 重新计算 `next_run`

**结果：**
```json
{
  "id": "work-reminder",
  "interval_minutes": 30,  // 已更新
  "next_run": "2026-01-23T12:30:00+08:00"  // 重新计算
}
```

### 场景 2：修改总结时间

**步骤：**
1. 修改 `config.yaml`：`summary_time: "23:00"`（从 11:00 改为 23:00）
2. 重启服务
3. 自动更新 tasks.json 中的 `time` 和 `next_run`

**结果：**
```json
{
  "id": "daily-summary",
  "time": "23:00",  // 已更新
  "next_run": "2026-01-23T23:00:00+08:00"  // 重新计算
}
```

### 场景 3：添加新任务

**步骤：**
1. 在代码中添加新任务初始化逻辑
2. 重启服务
3. 新任务自动添加到 tasks.json

## NextRun 计算逻辑

### 间隔型任务（work-reminder, log-rotate）

```go
func calculateNextReminderTime(from time.Time, intervalMinutes int) time.Time {
    interval := time.Duration(intervalMinutes) * time.Minute
    
    // 对齐到分钟边界
    next := from.Truncate(time.Minute).Add(interval)
    
    // 确保在未来
    for !next.After(from) {
        next = next.Add(interval)
    }
    
    return next
}
```

**特点：**
- 从当前时间开始计算
- 对齐到分钟边界
- 每次启动都重新计算

**示例：**
- 当前时间：12:37:25
- 间隔：45 分钟
- NextRun：13:22:00（12:37 向下对齐 + 45分钟）

### 每日型任务（daily-summary）

```go
func calculateNextSummaryTime(from time.Time, summaryTime string) time.Time {
    // 解析总结时间（如 "11:00"）
    hour, minute := ...
    
    // 构造今天的总结时间点
    todaySummaryTime := time.Date(...)
    
    // 如果已过今天的时间，返回明天
    if from.After(todaySummaryTime) {
        return todaySummaryTime.AddDate(0, 0, 1)
    }
    
    return todaySummaryTime
}
```

**特点：**
- 基于配置的时间点（如 11:00）
- 如果当天已过，计算为明天
- 每次启动都重新计算

**示例：**
- 当前时间：12:37:25
- 总结时间：11:00
- NextRun：2026-01-24 11:00:00（明天）

## 注意事项

### 1. 运行中的任务不受影响

重启前如果任务正在执行，重启后：
- 任务会重新调度
- NextRun 会重新计算
- 不会丢失数据（数据存储是独立的）

### 2. 手动修改 tasks.json 无效

如果手动编辑 tasks.json：
- 下次重启时会被覆盖
- 应该修改 config.yaml 而不是 tasks.json

### 3. 配置优先级

```
code > config.yaml > tasks.json
```

- 代码中的初始化逻辑是权威来源
- config.yaml 提供运行时参数
- tasks.json 是自动生成的，会被覆盖

## 最佳实践

### ✅ 推荐做法

1. **修改配置**：编辑 `config.yaml`
2. **重启服务**：让新配置生效
3. **验证结果**：检查日志和 tasks.json

### ❌ 不推荐做法

1. ~~直接编辑 tasks.json~~（会被覆盖）
2. ~~修改代码后不重启~~（不会生效）
3. ~~依赖 tasks.json 保存配置~~（应该用 config.yaml）

## 迁移指南

### 从旧版本升级

如果你之前手动修改过 tasks.json：

1. **备份现有配置**：
   ```bash
   cp run/tasks.json run/tasks.json.backup
   ```

2. **迁移配置到 config.yaml**：
   ```yaml
   # 从 tasks.json 中查看当前的间隔时间和总结时间
   minute_interval: 45  # work-reminder 的 interval_minutes
   summary_time: "11:00"  # daily-summary 的 time
   ```

3. **重启服务**：
   - 会根据 config.yaml 重新初始化
   - tasks.json 会被更新

4. **验证配置**：
   ```bash
   cat run/tasks.json
   ```

## 优势总结

| 方面 | 旧版本 | 新版本 ✓ |
|------|--------|----------|
| 配置一致性 | 可能不一致 | 始终一致 |
| 修改配置 | 需要手动编辑 tasks.json | 修改 config.yaml 即可 |
| 可预测性 | 不确定行为 | 行为明确 |
| 维护成本 | 高 | 低 |
| 出错风险 | 高 | 低 |

这个设计确保了**配置即代码**的理念，简化了系统的管理和维护！
