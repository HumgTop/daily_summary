# 延迟检测配置保存验证

## 问题发现

### 原始问题

在 `ShouldRun` 中修改 `config.NextRun` 后，配置不会被保存到 `tasks.json`。

**原因**：
```go
// 原来的逻辑
if !task.ShouldRun(now, config) {
    s.checkLogger.Printf("[SKIP] ...")
    continue  // 直接跳过，不保存配置
}

// ... 只有执行任务后才会保存
s.registry.UpdateTask(config)
s.registry.Save()
```

**问题**：
- `ShouldRun` 返回 `false` → 直接 `continue`
- 跳过了后面的 `UpdateTask` 和 `Save`
- **延迟检测中重新计算的 `NextRun` 丢失**

## 修复方案

### 修改后的逻辑

```go
// 修复后的逻辑
shouldRun := task.ShouldRun(now, config)

// ShouldRun 可能修改了 config（如延迟检测重新计算 NextRun），需要保存
if !shouldRun {
    s.checkLogger.Printf("[SKIP] ...")
    
    // 保存可能的配置更新
    if err := s.registry.UpdateTask(config); err != nil {
        log.Printf("Failed to update task config: %v", err)
    }
    if err := s.registry.Save(); err != nil {
        log.Printf("Failed to save task registry: %v", err)
    }
    
    continue
}
```

### 关键改进

1. **先调用 ShouldRun 并保存结果**
2. **检查结果前先保存配置**
3. **确保即使跳过执行，配置更新也会被持久化**

## 验证场景

### 场景 1：正常情况（无延迟）

**初始状态：**
```json
{
  "id": "work-reminder",
  "next_run": "2026-01-23T12:30:00+08:00"
}
```

**执行：**
```
当前时间: 12:29:00
NextRun: 12:30:00
延迟: -1分钟 (未到时间)
```

**结果：**
- `ShouldRun()` 返回 `false`（未到时间）
- **配置未修改**
- 不需要保存
- tasks.json 保持不变 ✓

### 场景 2：延迟检测触发

**初始状态：**
```json
{
  "id": "work-reminder",
  "interval_minutes": 45,
  "next_run": "2026-01-22T22:45:00+08:00"
}
```

**执行：**
```
当前时间: 2026-01-23 09:00:00
NextRun:     2026-01-22 22:45:00
延迟:        10小时15分钟
阈值:        22.5分钟 (45/2)
判断:        10h15m > 22.5m → 延迟过长
```

**`ShouldRun` 内部：**
```go
delay := now.Sub(config.NextRun)  // 10h15m
maxDelay := 22.5 * time.Minute

if delay > maxDelay {  // true
    log.Printf("Task delayed too long...")
    config.NextRun = t.calculateNextRun(now, 45)  // 重新计算 → 09:45:00
    return false
}
```

**调度器处理：**
```go
shouldRun := task.ShouldRun(now, config)  // 返回 false，但 config.NextRun 已被修改为 09:45

if !shouldRun {
    // ✅ 关键：保存配置更新
    s.registry.UpdateTask(config)
    s.registry.Save()
    continue
}
```

**最终状态：**
```json
{
  "id": "work-reminder",
  "interval_minutes": 45,
  "next_run": "2026-01-23T09:45:00+08:00"  // ✅ 已更新并保存
}
```

### 场景 3：任务执行后

**执行：**
```
当前时间: 09:45:00
NextRun: 09:45:00
延迟: 0
```

**流程：**
```go
shouldRun := task.ShouldRun(now, config)  // 返回 true

// 跳过 if !shouldRun 块

// 执行任务
task.Execute()
task.OnExecuted(now, config, err)  // OnExecuted 会再次更新 NextRun

// 保存配置
s.registry.UpdateTask(config)
s.registry.Save()
```

**结果：**
- 任务正常执行 ✓
- Next Run 更新为 10:30:00 ✓
- 配置正确保存 ✓

## 日志对比

### 修复前（❌ 配置丢失）

```
2026/01/23 09:00:00 [CHECK] Starting task check
2026/01/23 09:00:00 Task work-reminder delayed too long (10h15m0s > 22m30s), rescheduling...
2026/01/23 09:00:00 [SKIP] Task work-reminder: ShouldRun() returned false
2026/01/23 09:00:00 [CHECK] Task check completed
```

**tasks.json（未保存）：**
```json
{
  "next_run": "2026-01-22T22:45:00+08:00"  // ❌ 仍然是旧值
}
```

**下一次检查（09:01）：**
```
2026/01/23 09:01:00 Task work-reminder delayed too long (10h16m0s > 22m30s), rescheduling...
2026/01/23 09:01:00 [SKIP] Task work-reminder: ShouldRun() returned false
```
**无限循环** ❌

### 修复后（✅ 配置保存）

```
2026/01/23 09:00:00 [CHECK] Starting task check
2026/01/23 09:00:00 Task work-reminder delayed too long (10h15m0s > 22m30s), rescheduling...
2026/01/23 09:00:00 [SKIP] Task work-reminder: ShouldRun() returned false
```

**tasks.json（已保存）：**
```json
{
  "next_run": "2026-01-23T09:45:00+08:00"  // ✅ 已更新
}
```

**下一次检查（09:01）：**
```
2026/01/23 09:01:00 [SKIP] Task work-reminder: not yet time (NextRun: 2026-01-23 09:45:00)
```
**正常跳过** ✓

## 性能影响

### 额外的保存操作

**担心**：每次 `ShouldRun` 返回 false 都保存，会不会影响性能？

**分析**：

1. **大多数情况下配置未变**：
   - 未到时间 → 配置不变
   - 任务禁用 → 配置不变
   - **只有延迟检测触发时才会修改配置**

2. **保存操作很轻**：
   - UpdateTask: O(n) 遍历查找，n 很小（<10个任务）
   - Save: 序列化 JSON 并写文件，文件很小（<10KB）

3. **频率极低**：
   - 正常情况：每分钟检查，配置不变，保存相同内容（文件系统优化）
   - 延迟检测：每天可能触发0-1次

**结论**：性能影响可以忽略 ✓

## 测试建议

### 手动测试

1. **修改 tasks.json 模拟延迟**：
   ```bash
   # 修改 next_run 为昨天
   vi run/tasks.json
   ```

2. **重启服务**：
   ```bash
   ./scripts/install.sh
   ```

3. **查看日志**：
   ```bash
   tail -f run/logs/app.log | grep "delayed too long"
   ```

4. **验证 tasks.json**：
   ```bash
   cat run/tasks.json | jq '.tasks[] | select(.id=="work-reminder") | .next_run'
   ```

### 自动化测试

创建测试用例验证配置保存：

```go
func TestDelayDetectionSavesConfig(t *testing.T) {
    // 创建测试调度器
    tmpDir := t.TempDir()
    sched := NewScheduler(tmpDir, 0)
    
    // 注册任务
    task := tasks.NewReminderTask(...)
    sched.RegisterTask(task)
    
    // 设置过期的 NextRun
    config := &TaskConfig{
        ID: "work-reminder",
        NextRun: time.Now().Add(-10 * time.Hour),
        IntervalMinutes: 45,
        Enabled: true,
    }
    sched.registry.AddTask(config)
    
    // 执行检查
    sched.checkAndRunTasks()
    
    // 验证配置已更新并保存
    savedConfig := sched.registry.GetTask("work-reminder")
    if savedConfig.NextRun.Before(time.Now()) {
        t.Error("NextRun should be updated to future time")
    }
}
```

## 总结

### 修复前

| 情况 | 配置保存 | 问题 |
|------|---------|------|
| 延迟检测触发 | ❌ 不保存 | NextRun 更新丢失，无限循环检测 |
| 正常跳过 | ❌ 不保存 | 无影响（配置本来就没变） |
| 任务执行 | ✅ 保存 | 正常 |

### 修复后

| 情况 | 配置保存 | 结果 |
|------|---------|------|
| 延迟检测触发 | ✅ 保存 | NextRun 正确更新并持久化 ✓ |
| 正常跳过 | ✅ 保存 | 保存相同内容（无害） ✓ |
| 任务执行 | ✅ 保存 | 正常 ✓ |

**关键改进**：确保 `ShouldRun` 中的任何配置修改都会被持久化！
