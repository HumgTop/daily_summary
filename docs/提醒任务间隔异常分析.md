# 提醒任务间隔异常分析

## 1. 问题现象

用户反馈 `work-reminder` 任务的下一次运行时间 (`next_run`) 似乎异常，间隔远超配置的 45 分钟。

**上下文信息：**
- **任务上次运行时间 (`last_run`)**: `2026-02-02T12:53:00`
- **任务下次运行时间 (`next_run`)**: `2026-02-02T14:38:00`
- **配置间隔**: 45 分钟
- **实际间隔**: 1 小时 45 分钟

## 2. 日志分析

通过分析 `run/logs/app.log`，观察到以下关键事件序列：

```log
2026/02/02 12:53:00 Executing task: work-reminder (工作记录提醒)
2026/02/02 13:53:01 Task 工作记录提醒 failed: failed to show dialog: dialog timeout
2026/02/02 13:53:01 Next 工作记录提醒 at: 14:38:00
```

**关键发现：**
1. **任务执行耗时 1 小时**：任务在 `12:53:00` 开始执行，但在 `13:53:01` 失败，错误为 `dialog timeout`。这表明对话框等待了整整 1 个小时（3600秒）直到超时。
2. **下次运行时间计算**：在任务结束（超时）的时刻 `13:53:01`，系统计算了下一次运行时间。
   - 计算公式逻辑推测：`当前时间 + 间隔时间`
   - 计算结果：`13:53` + `45分钟` = `14:38`

## 3. 配置与代码分析

### 3.1 配置文件 (`config.yaml`)

检查配置文件发现：
```yaml
# 对话框超时时间（单位：秒）
dialog_timeout: 3600
```
`dialog_timeout` 被显式设置为 **3600 秒 (1 小时)**。这解释了为什么任务会阻塞等待 1 小时。

### 3.2 代码逻辑 (`internal/tasks/reminder.go`)

在 `OnExecuted` 方法中，代码明确使用了**当前实际时间**（即任务结束时间）来计算下一次运行时间，而不是任务开始时间。

```go
// internal/tasks/reminder.go

func (t *ReminderTask) OnExecuted(now time.Time, config *scheduler.TaskConfig, err error) {
    // ...
    // 计算下次执行时间
    // 使用当前实际时间而不是任务开始时间，避免用户长时间填写弹窗导致下次提醒时间过近
    actualNow := time.Now()
    config.NextRun = t.calculateNextRun(actualNow, config.IntervalMinutes)
    log.Printf("Next %s at: %s", t.Name(), config.NextRun.Format("15:04:05"))
}
```

代码注释表明这是一个有意为之的设计：避免用户在填写弹窗上花费很长时间后，刚填写完马上又触发下一次提醒。

## 4. 结论

**为什么间隔这么久？**

这一现象是由 **"超时机制"** 和 **"相对结束时间调度策略"** 共同作用的结果：

1. **超时耗时 (1h)**: 用户未处理弹窗，受 `dialog_timeout: 3600` 配置影响，程序等待了 1 小时。
2. **调度间隔 (+45m)**: 程序设计为在任务**结束**后才开始计算下一个 45 分钟间隔。

**总间隔 = 超时等待时间 (1h) + 任务间隔 (45m) = 1小时45分钟**

## 5. 建议

如果用户希望在错过提醒后能更快地恢复调度，或者不希望因为 AFK (Away From Keyboard) 导致整个日程主要推迟，建议：

**方案一：缩短超时时间（推荐）**
修改 `config.yaml`，将 `dialog_timeout` 设置为较短的时间，例如 5 分钟 (300秒)。
- 效果：如果用户 5 分钟不响应，对话框关闭。
- 新的调度：`12:53` (开始) -> `12:58` (超时) -> `13:43` (下次提醒)。
- 误差仅为 5 分钟。

**方案二：修改代码逻辑**
如果希望严格按照 "开始时间" 调度（即使这意味着超时后可能立即触发下一次，或者用户填写很久后立即触发下一次），需要修改 `reminder.go` 中的逻辑，使其基于 `config.LastRun` 计算 `NextRun`。但这可能导致在用户忙碌时产生连续弹窗的负面体验。
