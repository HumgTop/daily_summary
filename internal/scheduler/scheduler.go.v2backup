package scheduler

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"humg.top/daily_summary/internal/dialog"
	"humg.top/daily_summary/internal/models"
	"humg.top/daily_summary/internal/storage"
	"humg.top/daily_summary/internal/summary"
)

// Scheduler å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨ï¼ˆåŸºäºçŸ­å‘¨æœŸæ£€æŸ¥ï¼‰
type Scheduler struct {
	config    *models.Config
	dialog    dialog.Dialog
	storage   storage.Storage
	generator *summary.Generator
	stopCh    chan struct{}
	resetCh   chan struct{} // é‡ç½®ä¿¡å·é€šé“

	// æ—¶é—´ç‚¹è°ƒåº¦ï¼ˆæ›¿ä»£é•¿æ—¶é—´çš„ timerï¼‰
	checkInterval     time.Duration // æ£€æŸ¥é—´éš”ï¼ˆ1åˆ†é’Ÿï¼‰
	nextReminderTime  time.Time     // ä¸‹æ¬¡æé†’çš„ç»å¯¹æ—¶é—´ç‚¹
	lastSummaryDate   string        // ä¸Šæ¬¡ç”Ÿæˆæ€»ç»“çš„æ—¥æœŸï¼ˆé˜²æ­¢é‡å¤ï¼‰
}

// NewScheduler åˆ›å»ºè°ƒåº¦å™¨
func NewScheduler(
	config *models.Config,
	dialog dialog.Dialog,
	storage storage.Storage,
	generator *summary.Generator,
) *Scheduler {
	return &Scheduler{
		config:        config,
		dialog:        dialog,
		storage:       storage,
		generator:     generator,
		stopCh:        make(chan struct{}),
		resetCh:       make(chan struct{}, 1), // å¸¦ç¼“å†²ï¼Œé¿å…é˜»å¡
		checkInterval: 1 * time.Minute,        // å›ºå®š 1 åˆ†é’Ÿæ£€æŸ¥é—´éš”
	}
}

// Start å¯åŠ¨è°ƒåº¦å™¨
func (s *Scheduler) Start() error {
	log.Println("Scheduler started with time-point based scheduling (check interval: 1 minute)")

	// å¯åŠ¨ç»Ÿä¸€è°ƒåº¦å™¨
	go s.runScheduler()

	// å¯åŠ¨ä¿¡å·æ–‡ä»¶ç›‘æ§
	go s.watchResetSignal()

	// ç­‰å¾…åœæ­¢ä¿¡å·
	<-s.stopCh
	log.Println("Scheduler stopped")
	return nil
}

// Stop åœæ­¢è°ƒåº¦å™¨
func (s *Scheduler) Stop() {
	close(s.stopCh)
}

// runScheduler ç»Ÿä¸€è°ƒåº¦å™¨ï¼ˆåŸºäºçŸ­å‘¨æœŸæ£€æŸ¥ + ç»å¯¹æ—¶é—´ç‚¹ï¼‰
func (s *Scheduler) runScheduler() {
	// ä½¿ç”¨ 1 åˆ†é’Ÿçš„çŸ­å‘¨æœŸ ticker
	ticker := time.NewTicker(s.checkInterval)
	defer ticker.Stop()

	// åˆå§‹åŒ–ä¸‹æ¬¡æé†’æ—¶é—´
	now := time.Now()
	s.nextReminderTime = s.calculateNextReminderTime(now)

	// æ‰“å°è°ƒåº¦æ¨¡å¼
	if s.config.MinuteInterval > 0 {
		log.Printf("Using minute-based scheduling: every %d minute(s)", s.config.MinuteInterval)
	} else {
		log.Printf("Using hour-based scheduling: every %d hour(s)", s.config.HourlyInterval)
	}
	log.Printf("Next reminder at: %s", s.nextReminderTime.Format("15:04:05"))

	// è§£ææ€»ç»“æ—¶é—´
	summaryHour, summaryMin := parseSummaryTime(s.config.SummaryTime)
	log.Printf("Daily summary time: %02d:%02d", summaryHour, summaryMin)

	for {
		select {
		case <-ticker.C:
			now := time.Now()

			// 1. æ£€æŸ¥æ˜¯å¦éœ€è¦å¼¹çª—æé†’
			if !now.Before(s.nextReminderTime) {
				// è®¡ç®—å®é™…å»¶è¿Ÿ
				delay := now.Sub(s.nextReminderTime)
				if delay > 2*time.Minute {
					log.Printf("âš  Reminder delayed by %s (scheduled: %s, actual: %s)",
						delay.Round(time.Second),
						s.nextReminderTime.Format("15:04:05"),
						now.Format("15:04:05"))
				}

				// æ‰§è¡Œæé†’
				log.Printf("Triggering reminder (scheduled: %s, actual: %s)",
					s.nextReminderTime.Format("15:04:05"),
					now.Format("15:04:05"))
				s.showWorkEntryDialog()

				// è®¡ç®—ä¸‹æ¬¡æé†’æ—¶é—´
				s.nextReminderTime = s.calculateNextReminderTime(now)
				log.Printf("Next reminder at: %s", s.nextReminderTime.Format("15:04:05"))
			}

			// 2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ€»ç»“
			if s.shouldGenerateSummary(now, summaryHour, summaryMin) {
				log.Printf("Triggering daily summary generation (time: %s)", now.Format("15:04:05"))
				s.generateSummary()
				s.lastSummaryDate = now.Format("2006-01-02")
			}

		case <-s.resetCh:
			// ç”¨æˆ·æ‰‹åŠ¨æ·»åŠ è®°å½•ï¼Œé‡æ–°è®¡ç®—ä¸‹æ¬¡æ—¶é—´
			now := time.Now()
			oldTime := s.nextReminderTime
			s.nextReminderTime = s.calculateNextReminderTime(now)
			log.Printf("Reset signal received: rescheduling from %s to %s",
				oldTime.Format("15:04:05"),
				s.nextReminderTime.Format("15:04:05"))

		case <-s.stopCh:
			log.Println("Scheduler main loop exiting")
			return
		}
	}
}

// calculateNextReminderTime è®¡ç®—ä¸‹æ¬¡æé†’æ—¶é—´ï¼ˆåŸºäºç»å¯¹æ—¶é—´ç‚¹ï¼‰
func (s *Scheduler) calculateNextReminderTime(from time.Time) time.Time {
	var interval time.Duration

	if s.config.MinuteInterval > 0 {
		// åˆ†é’Ÿçº§è°ƒåº¦ï¼šå¯¹é½åˆ°åˆ†é’Ÿè¾¹ç•Œ
		interval = time.Duration(s.config.MinuteInterval) * time.Minute

		// å¯¹é½åˆ°åˆ†é’Ÿè¾¹ç•Œ
		next := from.Truncate(time.Minute).Add(interval)

		// ç¡®ä¿åœ¨æœªæ¥
		for !next.After(from) {
			next = next.Add(interval)
		}
		return next
	} else {
		// å°æ—¶çº§è°ƒåº¦ï¼šå¯¹é½åˆ°æ•´ç‚¹
		interval = time.Duration(s.config.HourlyInterval) * time.Hour

		// å¯¹é½åˆ°æ•´ç‚¹
		next := from.Truncate(time.Hour).Add(interval)

		// ç¡®ä¿åœ¨æœªæ¥
		for !next.After(from) {
			next = next.Add(interval)
		}
		return next
	}
}

// shouldGenerateSummary åˆ¤æ–­æ˜¯å¦åº”è¯¥ç”Ÿæˆæ€»ç»“
func (s *Scheduler) shouldGenerateSummary(now time.Time, summaryHour, summaryMin int) bool {
	// ä»Šå¤©çš„æ—¥æœŸ
	today := now.Format("2006-01-02")

	// å¦‚æœä»Šå¤©å·²ç»ç”Ÿæˆè¿‡ï¼Œè·³è¿‡
	if s.lastSummaryDate == today {
		return false
	}

	// æ„é€ ä»Šå¤©çš„æ€»ç»“æ—¶é—´ç‚¹
	todaySummaryTime := time.Date(now.Year(), now.Month(), now.Day(),
		summaryHour, summaryMin, 0, 0, now.Location())

	// æ£€æŸ¥æ˜¯å¦å·²è¿‡æ€»ç»“æ—¶é—´
	if !now.After(todaySummaryTime) {
		return false
	}

	// æ£€æŸ¥æ˜¨å¤©æ˜¯å¦æœ‰è®°å½•ä¸”æœªç”Ÿæˆæ€»ç»“
	yesterday := now.AddDate(0, 0, -1)
	yesterdayData, err := s.storage.GetDailyData(yesterday)
	if err != nil {
		// æ²¡æœ‰æ˜¨å¤©çš„æ•°æ®ï¼Œè·³è¿‡
		return false
	}

	// å¦‚æœæ˜¨å¤©æœ‰è®°å½•ä¸”æœªç”Ÿæˆæ€»ç»“ï¼Œè¿”å› true
	return len(yesterdayData.Entries) > 0 && !yesterdayData.SummaryGenerated
}

// showWorkEntryDialog æ˜¾ç¤ºå·¥ä½œè®°å½•å¯¹è¯æ¡†
func (s *Scheduler) showWorkEntryDialog() {
	now := time.Now()
	title := "å·¥ä½œè®°å½•"

	// è·å–ä»Šæ—¥æ‰€æœ‰è®°å½•
	todayData, err := s.storage.GetDailyData(now)
	var message string
	if err != nil {
		log.Printf("Failed to get today's data: %v", err)
		message = fmt.Sprintf("è¯·è¾“å…¥å·¥ä½œå†…å®¹ (å½“å‰æ—¶é—´: %s):", now.Format("15:04"))
	} else {
		message = s.buildDialogMessage(now, todayData)
	}

	content, ok, err := s.dialog.ShowInput(title, message, "")
	if err != nil {
		log.Printf("Failed to show dialog: %v", err)
		return
	}

	if !ok || content == "" {
		log.Println("User cancelled or input is empty, skipping this entry")
		return
	}

	// ä¿å­˜å·¥ä½œè®°å½•
	entry := models.WorkEntry{
		Timestamp: now,
		Content:   content,
	}

	if err := s.storage.SaveEntry(entry); err != nil {
		log.Printf("Failed to save entry: %v", err)
		return
	}

	log.Printf("Work entry saved: %s", content)
}

// buildDialogMessage æ„å»ºå¼¹çª—æ¶ˆæ¯
func (s *Scheduler) buildDialogMessage(now time.Time, todayData *models.DailyData) string {
	currentTime := now.Format("15:04")

	if len(todayData.Entries) == 0 {
		return fmt.Sprintf("ğŸ“ å½“å‰æ—¶é—´: %s\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nä»Šæ—¥æš‚æ— è®°å½•\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nè¯·è¾“å…¥å½“å‰å·¥ä½œå†…å®¹:", currentTime)
	}

	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("ğŸ“ å½“å‰æ—¶é—´: %s\n\n", currentTime))
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
	builder.WriteString("ä»Šæ—¥å·²è®°å½•ï¼š\n\n")

	for _, entry := range todayData.Entries {
		entryTime := entry.Timestamp.Format("15:04")
		builder.WriteString(fmt.Sprintf("  â–¸ %s    %s\n", entryTime, entry.Content))
	}

	builder.WriteString("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
	builder.WriteString("è¯·è¾“å…¥å½“å‰å·¥ä½œå†…å®¹:")
	return builder.String()
}

// generateSummary ç”Ÿæˆå‰ä¸€å¤©çš„å·¥ä½œæ€»ç»“
func (s *Scheduler) generateSummary() {
	// ç”Ÿæˆå‰ä¸€å¤©çš„æ€»ç»“
	yesterday := time.Now().AddDate(0, 0, -1)

	log.Printf("Generating summary for %s", yesterday.Format("2006-01-02"))

	if err := s.generator.GenerateDailySummary(yesterday); err != nil {
		log.Printf("Failed to generate summary: %v", err)
		return
	}

	// æ ‡è®°æ€»ç»“å·²ç”Ÿæˆ
	if err := s.storage.MarkSummaryGenerated(yesterday); err != nil {
		log.Printf("Failed to mark summary as generated: %v", err)
		// ä¸è¿”å›é”™è¯¯ï¼Œå› ä¸ºæ€»ç»“å·²ç»æˆåŠŸç”Ÿæˆ
	}

	log.Printf("Summary generated successfully for %s", yesterday.Format("2006-01-02"))
}

// parseSummaryTime è§£ææ€»ç»“æ—¶é—´
func parseSummaryTime(timeStr string) (hour, min int) {
	// é»˜è®¤ 00:00
	hour, min = 0, 0
	fmt.Sscanf(timeStr, "%d:%d", &hour, &min)
	return
}

// watchResetSignal ç›‘æ§é‡ç½®ä¿¡å·æ–‡ä»¶
func (s *Scheduler) watchResetSignal() {
	ticker := time.NewTicker(1 * time.Second) // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			if s.checkAndClearResetSignal() {
				// éé˜»å¡å‘é€é‡ç½®ä¿¡å·
				select {
				case s.resetCh <- struct{}{}:
					log.Println("Reset signal sent to scheduler")
				default:
					// é€šé“å·²æ»¡ï¼Œè¯´æ˜å·²æœ‰å¾…å¤„ç†çš„é‡ç½®ä¿¡å·
				}
			}
		case <-s.stopCh:
			return
		}
	}
}

// checkAndClearResetSignal æ£€æŸ¥å¹¶æ¸…é™¤é‡ç½®ä¿¡å·æ–‡ä»¶
func (s *Scheduler) checkAndClearResetSignal() bool {
	signalFile := s.getResetSignalPath()

	// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	if _, err := os.Stat(signalFile); os.IsNotExist(err) {
		return false
	}

	// åˆ é™¤ä¿¡å·æ–‡ä»¶
	if err := os.Remove(signalFile); err != nil {
		log.Printf("Failed to remove reset signal file: %v", err)
		return false
	}

	return true
}

// getResetSignalPath è·å–é‡ç½®ä¿¡å·æ–‡ä»¶è·¯å¾„
func (s *Scheduler) getResetSignalPath() string {
	// ä½¿ç”¨ dataDir çš„çˆ¶ç›®å½•ï¼ˆrun ç›®å½•ï¼‰
	runDir := filepath.Dir(s.config.DataDir)
	return filepath.Join(runDir, ".reset_signal")
}
